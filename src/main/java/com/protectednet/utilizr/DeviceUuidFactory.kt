package com.protectednet.utilizr

import android.Manifest
import android.annotation.SuppressLint
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.provider.Settings.Secure
import android.telephony.TelephonyManager
import android.util.Log
import androidx.core.app.ActivityCompat
import java.io.UnsupportedEncodingException
import java.lang.Exception
import java.util.*

class DeviceUuidFactory(val context: Context) {


    /**
     * Returns a unique UUID for the current android device. As with all UUIDs,
     * this unique ID is "very highly likely" to be unique across all Android
     * devices. Much more so than ANDROID_ID is.
     *
     * The UUID is generated by using ANDROID_ID as the base key if appropriate,
     * falling back on TelephonyManager.getDeviceID() if ANDROID_ID is known to
     * be incorrect, and finally falling back on a random UUID that's persisted
     * to SharedPreferences if getDeviceID() does not return a usable value.
     *
     * In some rare circumstances, this ID may change. In particular, if the
     * device is factory reset a new device ID may be generated. In addition, if
     * a user upgrades their phone from certain buggy implementations of Android
     * 2.2 to a newer, non-buggy version of Android, the device ID may change.
     * Or, if a user uninstalls your app on a device that has neither a proper
     * Android ID nor a Device ID, this ID may change on reinstallation.
     *
     * Note that if the code falls back on using TelephonyManager.getDeviceId(),
     * the resulting ID will NOT change after a factory reset. Something to be
     * aware of.
     *
     * Works around a bug in Android 2.2 for many devices when using ANDROID_ID
     * directly.
     *
     * @see http://code.google.com/p/android/issues/detail?id=10603
     *
     *
     * @return a UUID that may be used to uniquely identify your device for most
     * purposes.
     */
    val deviceUuid: UUID?
        get() {
            if (uuid == null) {
                getNewHardwareId()
            }
            return uuid
        }


    private fun getNewHardwareId() {
        if (uuid == null) {
            synchronized(this) {
                if (uuid == null) {
                    val prefs = context
                        .getSharedPreferences(PREFS_FILE, 0)
                    val id = prefs.getString(PREFS_DEVICE_ID, null)
                    if (id != null && id.contains("-")) {
                        // Use the ids previously computed and stored in the
                        // prefs file
                        uuid = UUID.fromString(id)
                    } else {
                        val androidId = Secure.getString(
                            context.contentResolver, Secure.ANDROID_ID
                        )
                        // Use the Android ID unless it's broken, in which case
                        // fallback on deviceId,
                        // unless it's not available, then fallback on a random
                        // number which we store to a prefs file
                        try {
                            uuid = if ("9774d56d682e549c" != androidId) {
                                UUID.nameUUIDFromBytes(
                                    androidId
                                        .toByteArray(charset("utf8"))
                                )
                            } else {
                                UUID.randomUUID()
                            }
                        } catch (e: UnsupportedEncodingException) {
                            throw RuntimeException(e)
                        }

                        // Write the value out to the prefs file
                        prefs.edit()
                            .putString(PREFS_DEVICE_ID, uuid!!.toString())
                            .commit()
                    }
                }
            }
        }
    }

    @SuppressLint("HardwareIds")
    fun getLegacyHardwareId(a: Activity?, shouldOverwriteNewHardwareId: Boolean=false): String? {
        val prefs = context.getSharedPreferences(PREFS_FILE, 0)
        var id = prefs.getString(PREFS_DEVICE_ID, null)
        var udid: String? = null
        if (id != null && id.isNotEmpty()) {//could be new hardware uuid string
            if (id.contains("-")) {
                if (shouldOverwriteNewHardwareId)
                    id = null
                try {
                    udid = UUID.fromString(id).toString()
                } catch (e: Exception) {
                    Log.e("GetNewHardwareId", e.message ?: "")
                }
            }
            if (udid == null)
                udid = id
        }

        if (udid == null)
            udid = Secure.getString(context.contentResolver, Secure.ANDROID_ID)
        if (udid === "9774d56d682e549c" || udid == null) {
//            in unlikely case that the android ID is null or bugged (http://stackoverflow.com/questions/6106681/android-how-are-you-dealing-with-9774d56d682e549c-android-id)
//            fall back to telephony manager
            if (ActivityCompat.checkSelfPermission(
                    context,
                    Manifest.permission.READ_PHONE_STATE
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
                    a?.requestPermissions(
                        arrayOf(Manifest.permission.READ_PHONE_STATE),
                        PHONE_STATE_REQUEST
                    )
                return null
            }
//            udid =
//                (context.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager).deviceId
        }

        return udid
    }

    companion object {

        const val PREFS_FILE = "device_id.xml"
        const val PREFS_DEVICE_ID = "device_id"
//        const val PREFS_DEVICE_ID_LEGACY = "device_id_legacy"
        const val PHONE_STATE_REQUEST: Int = 9767

        @Volatile
        private var uuid: UUID? = null
    }
}